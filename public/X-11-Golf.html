<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Minigolf Master (Top Down)</title>
    <!-- Load Tailwind CSS for utility classes -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Chivo:wght@700&display=swap" rel="stylesheet">
    
    <style>
        /* Custom CSS for the Game Canvas and Feel */
        body {
            font-family: 'Chivo', sans-serif;
            background-color: #0b1a2e; /* Dark theme background */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding: 10px;
        }

        #game-container {
            border: 4px solid #10b981; /* Teal border for flair */
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
            overflow: hidden;
            max-width: 900px;
            width: 95vw; /* Responsive width */
        }
        
        canvas {
            display: block;
            /* Uniform grass color for top-down view */
            background-color: #388e3c; 
            width: 100%;
            height: auto;
        }

        .ui-panel {
            background-color: #1f2937; /* Dark UI background */
            color: white;
            padding: 1rem;
            border-radius: 0 0 12px 12px;
        }

        .stat-item {
            font-size: 1.1rem;
            font-weight: 700;
        }

        .stat-item span {
            color: #fcd34d; /* Gold/Yellow accent */
            font-size: 1.5rem;
            margin-left: 0.5rem;
        }
    </style>
</head>
<body>

    <!-- UI Panel -->
    <div id="game-container" class="mb-4">
        <canvas id="golfCanvas"></canvas>
    </div>
    
    <div class="ui-panel rounded-t-xl w-full max-w-lg mx-auto flex justify-between items-center shadow-lg">
        <div class="stat-item">
            Hole: <span id="holeNum">1</span>
        </div>
        <div class="stat-item">
            Strokes: <span id="strokesCount">0</span>
        </div>
        <button id="resetButton" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300 shadow-md">
            Reset Hole
        </button>
    </div>

    <!-- Message Modal (Hidden by Default) -->
    <div id="messageModal" class="hidden fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50">
        <div class="bg-gray-800 p-8 rounded-xl shadow-2xl text-center border-t-4 border-yellow-400 max-w-sm">
            <h2 id="modalTitle" class="text-4xl text-yellow-300 mb-4 font-bold">HOLE IN ONE!</h2>
            <p id="modalMessage" class="text-white text-xl mb-6">You sunk the ball! Moving to the next challenge.</p>
            <button id="modalButton" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg transition duration-300 shadow-md">
                Continue
            </button>
        </div>
    </div>

    <script>
        // --- Canvas and Context Setup ---
        const canvas = document.getElementById('golfCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('game-container');
        
        // UI Elements
        const holeNumEl = document.getElementById('holeNum');
        const strokesCountEl = document.getElementById('strokesCount');
        const resetButton = document.getElementById('resetButton');
        const messageModal = document.getElementById('messageModal');
        const modalTitle = document.getElementById('modalTitle');
        const modalMessage = document.getElementById('modalMessage');
        const modalButton = document.getElementById('modalButton');

        // --- Game Constants ---
        const GAME_WIDTH = 800; // Conceptual game width
        const GAME_HEIGHT = 500; // Conceptual game height (Now represents top-down Y boundary)
        const BALL_RADIUS = 8;
        const HOLE_RADIUS = 12;
        const MAX_POWER = 350; // Max magnitude of shot velocity
        const GRASS_FRICTION_FACTOR = 0.65; // Base velocity decay factor (for grass)
        const SAND_FRICTION_FACTOR = 0.30; // High friction for sand traps
        const STOP_THRESHOLD = 2; // Speed below which the ball stops
        
        // Scaling factor to keep game elements proportional on different screen sizes
        let scaleX = 1;
        let scaleY = 1;

        // --- Game State ---
        // Ball position is now purely 2D (x, y plane)
        let ball = { x: 50, y: 50, vx: 0, vy: 0 };
        let hole = { x: 700, y: 400 };
        let startPosition = { x: 50, y: 50 }; // Store starting position for current hole
        let strokes = 0;
        let isDragging = false;
        let isMoving = false;
        let dragStart = { x: 0, y: 0 };
        let dragEnd = { x: 0, y: 0 };
        let currentHole = 1;

        // --- Course Data (Top-down Coordinates) ---
        // Coordinates (x, y, w, h) are now absolute game coordinates.
        const courses = [
            // Hole 1: Simple shot with Sand Trap
            { 
                startX: 50, holeX: 750, startY: 250, holeY: 250, par: 3, 
                obstacles: [], 
                sandTraps: [{ x: 300, y: 200, w: 200, h: 100 }], 
                waterHazards: [] 
            },
            
            // Hole 2: Vertical Wall and Water Hazard (Requires bouncing)
            { 
                startX: 100, holeX: 700, startY: 50, holeY: 400, par: 4, 
                obstacles: [
                    { x: 350, y: 50, w: 20, h: 300 } 
                ],
                sandTraps: [],
                waterHazards: [{ x: 100, y: 150, w: 100, h: 100 }]
            },
            
            // Hole 3: Horizontal Barrier and Sand Trap maze
            { 
                startX: 50, holeX: 750, startY: 50, holeY: 450, par: 4, 
                obstacles: [
                    { x: 0, y: 200, w: 400, h: 20 }, // Left block
                    { x: 400, y: 350, w: 400, h: 20 } // Right block
                ],
                sandTraps: [{ x: 50, y: 400, w: 100, h: 50 }, { x: 650, y: 300, w: 100, h: 50 }],
                waterHazards: []
            },
            
            // Hole 4: L-Shape Maze, Sand, and Water Combo
            {
                startX: 50, holeX: 750, startY: 250, holeY: 250, par: 5,
                obstacles: [
                    { x: 150, y: 50, w: 20, h: 400 }, // Vertical wall
                    { x: 150, y: 50, w: 300, h: 20 },  // Horizontal top wall
                    { x: 500, y: 150, w: 20, h: 300 } // Barrier near end
                ],
                sandTraps: [{ x: 600, y: 50, w: 150, h: 100 }],
                waterHazards: [{ x: 250, y: 300, w: 150, h: 100 }]
            }
        ];
        
        // --- Helper Functions ---

        /** Converts screen coordinates (mouse/touch) to game coordinates. */
        function getGameCoords(screenX, screenY) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: (screenX - rect.left) / scaleX,
                y: (screenY - rect.top) / scaleY
            };
        }

        /** Shows the custom message modal. */
        function showMessage(title, message, isVictory) {
            modalTitle.textContent = title;
            modalMessage.textContent = message;
            modalButton.textContent = isVictory ? 'Next Hole' : 'OK';
            modalButton.onclick = isVictory ? nextHole : hideMessage;
            messageModal.classList.remove('hidden');
        }

        /** Hides the custom message modal. */
        function hideMessage() {
            messageModal.classList.add('hidden');
        }


        // --- Initialization and Resizing ---

        function resizeCanvas() {
            // Set canvas size based on container width
            const containerWidth = container.clientWidth;
            canvas.width = containerWidth;
            canvas.height = (containerWidth / GAME_WIDTH) * GAME_HEIGHT; // Maintain aspect ratio

            // Update scaling factors
            scaleX = canvas.width / GAME_WIDTH;
            scaleY = canvas.height / GAME_HEIGHT;

            // Redraw everything
            draw();
        }

        // --- Game Setup ---

        function setupHole(holeIndex) {
            if (holeIndex >= courses.length) {
                showMessage(
                    "Course Complete!", 
                    `You finished the entire course in a grand total of ${strokes} strokes. Great job!`, 
                    false
                );
                currentHole = 1; // Reset to loop the course
                strokes = 0;
                setupHole(currentHole - 1);
                return;
            }

            const course = courses[holeIndex];
            currentHole = holeIndex + 1;
            
            // Set start and hole positions for the current course
            startPosition = { x: course.startX, y: course.startY };
            hole.x = course.holeX;
            hole.y = course.holeY;

            // Reset ball position
            ball.x = startPosition.x;
            ball.y = startPosition.y;
            ball.vx = 0;
            ball.vy = 0;
            
            isMoving = false;
            isDragging = false;
            strokes = 0; // Strokes count for the current hole
            
            holeNumEl.textContent = currentHole;
            strokesCountEl.textContent = strokes;
            draw();
        }
        
        function nextHole() {
            hideMessage();
            setupHole(currentHole);
        }

        // --- Game Input Handlers ---

        function handleShot() {
            if (isMoving) return;

            // Calculate distance and angle of drag
            const dx = dragStart.x - dragEnd.x;
            const dy = dragStart.y - dragEnd.y;
            const distance = Math.min(Math.hypot(dx, dy), 150); // Cap max drag distance

            // Calculate velocity components
            const powerRatio = distance / 150;
            const velocity = MAX_POWER * powerRatio;
            
            // Apply velocity
            ball.vx = velocity * (dx / distance);
            ball.vy = velocity * (dy / distance);
            
            ball.vx = isNaN(ball.vx) ? 0 : ball.vx;
            ball.vy = isNaN(ball.vy) ? 0 : ball.vy;

            // Increment strokes
            strokes++;
            strokesCountEl.textContent = strokes;
            
            isDragging = false;
            isMoving = true;
        }

        // Mouse/Touch Handlers 
        canvas.addEventListener('mousedown', (e) => {
            if (isMoving) return;
            const gameCoords = getGameCoords(e.clientX, e.clientY);
            if (Math.hypot(gameCoords.x - ball.x, gameCoords.y - ball.y) < BALL_RADIUS + 30) {
                isDragging = true;
                dragStart = gameCoords;
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                dragEnd = getGameCoords(e.clientX, e.clientY);
                draw();
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (isDragging) {
                dragEnd = getGameCoords(e.clientX, e.clientY);
                handleShot();
            }
        });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (isMoving) return;
            const touch = e.touches[0];
            const gameCoords = getGameCoords(touch.clientX, touch.clientY);
            
            if (Math.hypot(gameCoords.x - ball.x, gameCoords.y - ball.y) < BALL_RADIUS + 50) {
                isDragging = true;
                dragStart = gameCoords;
                dragEnd = gameCoords;
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (isDragging) {
                const touch = e.touches[0];
                dragEnd = getGameCoords(touch.clientX, touch.clientY);
                draw();
            }
        });

        canvas.addEventListener('touchend', (e) => {
            if (isDragging) {
                handleShot();
            }
        });
        
        // Reset button handler
        resetButton.addEventListener('click', () => {
            setupHole(currentHole - 1);
        });

        // --- Hazard Penalty Handler ---

        function waterPenalty() {
            isMoving = false;
            ball.vx = 0;
            ball.vy = 0;
            
            // Reset ball to starting position of the hole
            ball.x = startPosition.x;
            ball.y = startPosition.y;
            
            showMessage(
                "SPLASH!", 
                "Your ball landed in the water hazard! That shot counts as a penalty stroke. Try again from the tee box.", 
                false
            );
        }

        // --- Game Physics ---

        function update(dt) {
            if (!isMoving) return;

            let currentFriction = GRASS_FRICTION_FACTOR;
            const course = courses[currentHole - 1];

            // 1. Check for Water Collision
            // A ball entering water immediately results in a penalty in top-down view.
            const inWater = course.waterHazards.some(hazard => 
                ball.x > hazard.x - BALL_RADIUS && ball.x < hazard.x + hazard.w + BALL_RADIUS &&
                ball.y > hazard.y - BALL_RADIUS && ball.y < hazard.y + hazard.h + BALL_RADIUS
            );

            if (inWater) {
                waterPenalty();
                return; 
            }
            
            // 2. Check for Sand Trap (if not in water)
            const inSand = course.sandTraps.some(trap => 
                ball.x > trap.x - BALL_RADIUS && ball.x < trap.x + trap.w + BALL_RADIUS &&
                ball.y > trap.y - BALL_RADIUS && ball.y < trap.y + trap.h + BALL_RADIUS
            );

            if (inSand) {
                currentFriction = SAND_FRICTION_FACTOR;
            }

            // Apply friction across the 2D plane
            ball.vx *= Math.pow(currentFriction, dt);
            ball.vy *= Math.pow(currentFriction, dt);
            
            // --- Update Position ---
            ball.x += ball.vx * dt;
            ball.y += ball.vy * dt;

            // --- Collision Detection (Walls) ---
            const restitution = 0.7; // Wall bounciness
            
            course.obstacles.forEach(obs => {
                // Find the closest point on the obstacle to the ball center
                const closestX = Math.max(obs.x, Math.min(ball.x, obs.x + obs.w));
                const closestY = Math.max(obs.y, Math.min(ball.y, obs.y + obs.h));

                const dx = ball.x - closestX;
                const dy = ball.y - closestY;
                const distanceSq = dx * dx + dy * dy;

                if (distanceSq < BALL_RADIUS * BALL_RADIUS) {
                    // Collision detected!
                    const distance = Math.sqrt(distanceSq);
                    const penetrationDepth = BALL_RADIUS - distance;
                    
                    // To resolve the collision, we calculate the normal vector (nx, ny)
                    const nx = dx / distance;
                    const ny = dy / distance;

                    // 1. Resolve position (push ball out)
                    ball.x += nx * penetrationDepth;
                    ball.y += ny * penetrationDepth;

                    // 2. Resolve velocity (bounce)
                    const dotProduct = ball.vx * nx + ball.vy * ny;
                    
                    // Reflect the velocity vector
                    ball.vx = ball.vx - 2 * dotProduct * nx;
                    ball.vy = ball.vy - 2 * dotProduct * ny;

                    // Apply restitution
                    ball.vx *= restitution;
                    ball.vy *= restitution;
                }
            });

            // --- World Boundary Check ---
            // Reflect off the outer boundaries
            if (ball.x < BALL_RADIUS) {
                ball.x = BALL_RADIUS;
                ball.vx *= -0.8;
            }
            if (ball.x > GAME_WIDTH - BALL_RADIUS) {
                ball.x = GAME_WIDTH - BALL_RADIUS;
                ball.vx *= -0.8;
            }
            if (ball.y < BALL_RADIUS) {
                ball.y = BALL_RADIUS;
                ball.vy *= -0.8;
            }
            if (ball.y > GAME_HEIGHT - BALL_RADIUS) {
                ball.y = GAME_HEIGHT - BALL_RADIUS;
                ball.vy *= -0.8;
            }

            // 3. Hole Collision (Sink check)
            const dx_hole = ball.x - hole.x;
            const dy_hole = ball.y - hole.y; 

            if (Math.hypot(dx_hole, dy_hole) < HOLE_RADIUS - 5) {
                // Ball is close enough, slow it down to simulate falling in
                ball.vx *= 0.5;
                ball.vy *= 0.5;
                
                // If ball is slow enough, it sinks!
                if (Math.hypot(ball.vx, ball.vy) < 100) {
                    isMoving = false;
                    holeInOne();
                    return;
                }
            }
            
            // --- Stop Check ---
            const currentSpeedSq = ball.vx * ball.vx + ball.vy * ball.vy;
            if (currentSpeedSq < STOP_THRESHOLD * STOP_THRESHOLD) {
                isMoving = false;
                ball.vx = 0;
                ball.vy = 0;
            }
        }

        // --- Hole In One Handler ---

        function holeInOne() {
            let title, message;
            
            const par = courses[currentHole - 1].par;
            if (strokes === 1) {
                title = "HOLE IN ONE!";
                message = "Incredible shot! Moving to the next challenge.";
            } else if (strokes <= par) {
                title = "NICE SHOT!";
                message = `You made it in ${strokes} strokes (Par is ${par}).`;
            } else {
                title = "GOT IT!";
                message = `You made it, but took ${strokes} strokes (Par is ${par}).`;
            }
            
            // Fade the ball into the hole visually
            setTimeout(() => {
                // Visually shrink the ball into the hole
                ball.radius = 0; 
                draw();
                setTimeout(() => {
                    showMessage(title, message, true);
                }, 500);
            }, 100);
        }

        // --- Rendering ---

        function draw() {
            ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            
            ctx.save();
            ctx.scale(scaleX, scaleY);
            
            const currentCourse = courses[currentHole - 1];

            // --- Draw Ground (Already set by canvas background-color, but draw full fill just in case) ---
            ctx.fillStyle = '#388e3c'; // Darker grass color
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

            // --- Draw Water Hazards ---
            ctx.fillStyle = '#60a5fa'; // Light blue water
            currentCourse.waterHazards.forEach(hazard => {
                ctx.fillRect(hazard.x, hazard.y, hazard.w, hazard.h);
            });

            // --- Draw Sand Traps ---
            ctx.fillStyle = '#fcd34d'; // Yellow/Gold sand
            currentCourse.sandTraps.forEach(trap => {
                ctx.fillRect(trap.x, trap.y, trap.w, trap.h); 
            });

            // --- Draw Obstacles (Walls/Bunkers) ---
            ctx.fillStyle = '#9c3f3f'; // Brick/Wood color for obstacles
            ctx.strokeStyle = '#632525';
            ctx.lineWidth = 2;

            currentCourse.obstacles.forEach(obs => {
                ctx.fillRect(obs.x, obs.y, obs.w, obs.h);
                ctx.strokeRect(obs.x, obs.y, obs.w, obs.h);
            });


            // --- Draw Hole ---
            ctx.beginPath();
            ctx.arc(hole.x, hole.y, HOLE_RADIUS, 0, Math.PI * 2, false); 
            ctx.closePath();
            ctx.fillStyle = '#1e2d3b'; // Hole color (very dark)
            ctx.fill();

            // --- Draw Flag Pin (top-down view) ---
            ctx.fillStyle = '#fcd34d'; // Gold color
            ctx.fillRect(hole.x, hole.y - 70, 4, 70); // Pole (starting from hole center up)
            ctx.fillStyle = '#ef4444'; // Red flag
            ctx.beginPath();
            ctx.moveTo(hole.x + 4, hole.y - 70);
            ctx.lineTo(hole.x + 4, hole.y - 50);
            ctx.lineTo(hole.x + 24, hole.y - 60);
            ctx.closePath();
            ctx.fill();

            // --- Draw Ball ---
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, BALL_RADIUS, 0, Math.PI * 2, true);
            ctx.closePath();
            ctx.fillStyle = '#f9fafb'; // White ball
            ctx.strokeStyle = '#374151'; // Dark border
            ctx.lineWidth = 1;
            ctx.fill();
            ctx.stroke();

            // --- Draw Power Line (if dragging) ---
            if (isDragging && !isMoving) {
                const dx = dragStart.x - dragEnd.x;
                const dy = dragStart.y - dragEnd.y;
                const distance = Math.min(Math.hypot(dx, dy), 150);
                
                const powerRatio = distance / 150;
                const lineColor = `rgba(255, ${255 * (1 - powerRatio)}, ${255 * (1 - powerRatio)}, 0.8)`; 
                const lineWidth = 3 + powerRatio * 5;

                ctx.beginPath();
                ctx.moveTo(ball.x, ball.y);
                ctx.lineTo(
                    ball.x + (dx * (distance / 150)),
                    ball.y + (dy * (distance / 150))
                );
                ctx.strokeStyle = lineColor;
                ctx.lineWidth = lineWidth;
                ctx.lineCap = 'round';
                ctx.stroke();
            }

            ctx.restore();
        }

        // --- Game Loop ---
        let lastTime = 0;
        function gameLoop(currentTime) {
            const dt = (currentTime - lastTime) / 1000;
            lastTime = currentTime;

            update(dt);
            draw();

            requestAnimationFrame(gameLoop);
        }

        // --- Start Game ---
        window.onload = () => {
            resizeCanvas(); 
            setupHole(0); 
            requestAnimationFrame(gameLoop); 
        };

        window.addEventListener('resize', resizeCanvas); 
    </script>
</body>
</html>
