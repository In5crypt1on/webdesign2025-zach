<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Physics Box</title>
    <!-- Three.js (3D Rendering) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Cannon.js (Physics Engine) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <!-- Orbit Controls for 3D navigation (allows camera dragging) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #FFFFFF; }
        canvas { display: block; }
    </style>
</head>
<body>
    <div id="info" class="absolute top-4 left-4 text-white p-3 rounded-lg bg-gray-900 bg-opacity-75 z-10 font-mono text-sm shadow-xl">
        1. Drag mouse/touch to orbit camera.<br>
        2. <span class="text-yellow-400 font-bold">Use WASD keys to push the box!</span>
    </div>

    <script>
        // --- Global Variables ---
        let scene, camera, renderer, controls;
        let world, boxBody, boxMesh;
        const timeStep = 1 / 60; // Physics time step
        const moveForce = 30; // Magnitude of the impulse applied by WASD

        /**
         * Initializes the Three.js scene, camera, and renderer.
         */
        function initThree() {
            // Scene Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e); // Dark space background

            // Camera Setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(5, 5, 8); // Start position above the scene

            // Renderer Setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // Controls (Orbiting)
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; // For smoother movement
            controls.dampingFactor = 0.05;
            controls.minDistance = 2;
            controls.maxDistance = 20;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 3); // Soft white light
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 2.5);
            directionalLight.position.set(10, 15, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -10;
            directionalLight.shadow.camera.right = 10;
            directionalLight.shadow.camera.top = 10;
            directionalLight.shadow.camera.bottom = -10;
            scene.add(directionalLight);
        }

        /**
         * Initializes the Cannon.js physics world and rigid bodies.
         */
        function initCannon() {
            world = new CANNON.World();
            world.gravity.set(0, -9.82, 0); // Standard Earth gravity
            world.broadphase = new CANNON.NaiveBroadphase();
            world.solver.iterations = 10;

            // 1. Create the Ground (Plane)
            const groundShape = new CANNON.Plane();
            const groundBody = new CANNON.Body({ mass: 0 }); // Mass 0 means static (unmovable)
            groundBody.addShape(groundShape);
            groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2); // Rotate to lay flat
            world.addBody(groundBody);

            // 2. Create the Box
            const boxMass = 5;
            const boxSize = 1;
            const boxShape = new CANNON.Box(new CANNON.Vec3(boxSize / 2, boxSize / 2, boxSize / 2));
            boxBody = new CANNON.Body({ mass: boxMass });
            boxBody.addShape(boxShape);
            boxBody.position.set(0, 5, 0); // Start 5 units in the air
            world.addBody(boxBody);

 // 3. Create a Pushable Sphere (The obstacle/target)
            const sphereMass = 2; // Lighter mass than the box
            const sphereRadius = 0.5;
            const sphereShape = new CANNON.Sphere(sphereRadius);
            sphereBody = new CANNON.Body({ mass: sphereMass });
            sphereBody.addShape(sphereShape);
            sphereBody.position.set(2, 5, -2); // Start off to the side, slightly elevated
            world.addBody(sphereBody);



        }

        /**
         * Creates the visual Three.js meshes.
         */
        function createMeshes() {
            // Ground Mesh (Checkerboard pattern for visual depth)
            const white = 0xaaaaaa;
            const black = 0x666666;
            const size = 100;
            const step = 2;
            const geometry = new THREE.PlaneGeometry(size, size, size / step, size / step);
            
            const groundMesh = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial({ color: white, shininess: 50, side: THREE.DoubleSide }));
            groundMesh.rotation.x = -Math.PI / 2;
            groundMesh.receiveShadow = true;

            // Apply checkerboard pattern to vertices 
            const colorAttribute = new THREE.Float32BufferAttribute(new Float32Array(geometry.attributes.position.count * 3), 3);
            for (let i = 0; i < geometry.attributes.position.count; i++) {
                const x = geometry.attributes.position.getX(i);
                const y = geometry.attributes.position.getY(i);
                
                // Color based on checkerboard pattern
                const color = ((Math.floor(x / step) + Math.floor(y / step)) % 2 === 0) ? black : white;
                // Normalize color components
                const r = ((color >> 16) & 255) / 255;
                const g = ((color >> 8) & 255) / 255;
                const b = (color & 255) / 255;
                colorAttribute.setXYZ(i, r, g, b);
            }
            geometry.setAttribute('color', colorAttribute);

            const checkMaterial = new THREE.MeshBasicMaterial({ vertexColors: true, side: THREE.DoubleSide });
            groundMesh.material = checkMaterial;

            scene.add(groundMesh);


            // Box Mesh (Wood-like appearance)
            const boxGeometry = new THREE.BoxGeometry(1, 1, 1);
            const textureLoader = new THREE.TextureLoader();
            const woodTexture = textureLoader.load('https://threejs.org/examples/textures/crate.gif'); 

            const boxMaterial = new THREE.MeshStandardMaterial({ 
                map: woodTexture, // Assign the loaded texture
                color: 0x00ff00, // Set color to white to show the texture's true colors
                roughness: 0.1,
                metalness: 0.3
            });
            boxMesh = new THREE.Mesh(boxGeometry, boxMaterial);
            boxMesh.castShadow = true;
            boxMesh.receiveShadow = true;
            boxMesh.position.y = 5; // Initial position
            scene.add(boxMesh);

// Sphere Mesh (Orange ball - pushable object)
            const sphereGeometry = new THREE.SphereGeometry(0.5, 32, 32);
            const sphereMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xff0000, // Bright Orange color
                roughness: 0.3, 
                metalness: 0.5
            });
            sphereMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
            sphereMesh.castShadow = true;
            sphereMesh.receiveShadow = true;
            sphereMesh.position.set(2, 5, -2); // Initial position matches Cannon body
            scene.add(sphereMesh);
        }
        
        /**
         * Handles keyboard input to apply directional impulses to the box.
         */
        function handleKeyDown(event) {
            if (!boxBody) return;

            const impulse = new CANNON.Vec3(0, 0, 0);
            const relativePosition = new CANNON.Vec3(0, 0, 0); // Apply impulse at the center of mass

            // Prevent default browser behavior (like scrolling with space/arrows)
            if (['w', 'a', 's', 'd', ' '].includes(event.key.toLowerCase())) {
                event.preventDefault();
            }

            switch (event.key.toLowerCase()) {
                case 'w':
                    // Forward push (towards -Z axis)
                    impulse.z = -moveForce;
                    break;
                case 's':
                    // Backward push (towards +Z axis)
                    impulse.z = moveForce;
                    break;
                case 'a':
                    // Left push (towards -X axis)
                    impulse.x = -moveForce;
                    break;
                case 'd':
                    // Right push (towards +X axis)
                    impulse.x = moveForce;
                    break;
                case ' ':
                    // Spacebar for a small jump
                    impulse.y = 50; 
                    break;
                default:
                    return; // Do nothing for other keys
            }

            // Apply the calculated impulse
            boxBody.applyImpulse(impulse, relativePosition);
        }

        /**
         * Main animation loop. Updates physics and rendering.
         */
        function animate() {
            requestAnimationFrame(animate);

            // 1. Update Physics
            world.step(timeStep);

            // 2. Sync Three.js mesh with Cannon.js body position and rotation
            boxMesh.position.copy(boxBody.position);
            boxMesh.quaternion.copy(boxBody.quaternion);

            // Sphere Sync (New)
            sphereMesh.position.copy(sphereBody.position);
            sphereMesh.quaternion.copy(sphereBody.quaternion); // Quaternions are used even for spheres, though rotation is less noticeable

            
            // If the box falls too far, reset it (e.g., if it rolls off the plane)
            if (boxBody.position.y < -1) {
                boxBody.position.set(0, 5, 0); // Reset position
                boxBody.velocity.set(0, 0, 0);   // Stop movement
                boxBody.angularVelocity.set(0, 0, 0); // Stop rotation
            }

            if (sphereBody.position.y < 1) {
                sphereBody.position.set(0, 5, 0); // Reset position
                sphereBody.velocity.set(0, 0, 0);   // Stop movement
                sphereBody.angularVelocity.set(0, 0, 0); // Stop rotation
            }


            // 3. Update Controls and Render
            controls.update(); // Update orbit controls
            renderer.render(scene, camera);
        }

        /**
         * Handles window resizing to keep the canvas full screen and responsive.
         */
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Start Application ---
        window.onload = function () {
            // Initialize rendering and physics
            initThree();
            initCannon();
            createMeshes();
            
            // Add keyboard listener for WASD movement
            window.addEventListener('keydown', handleKeyDown, false);

            // Start the loop
            animate(); 

            // Handle resizing
            window.addEventListener('resize', onWindowResize, false);
        }
    </script>
</body>
</html>